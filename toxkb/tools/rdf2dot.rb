# Title:: RDFGRaph
# Description :: Takes RDF statements and converts into GraphViz Object. 
#! /usr/bin/ruby

require 'rubygems'
require 'graphviz'
require 'graphviz/theory'
require 'digest/md5'
require 'ostruct'
require 'optparse'
require 'logger'
require 'rdf'
require 'rdf/ntriples'
require 'digest/md5'

gem 'addressable', '>= 2.2.4'

require 'addressable/uri'
require 'addressable/template'


#"%06x" % (rand * 0xffffff
module RDFVisualGraph
  class Rdf2Dot
    
      # create a graph object to load RDF statements into.
      # @param [String] input the oath of hte input RDF.
      # @params [Hash] params the options specified to generate the graph.
      #         :use => layout type
      #         :type => directed or undirected
      #         :splines => use splines?
      #         :output => output type
      #         :cluster => group nodes by specific cluster generated by namespaces
      #         :showedges => show edge labels?
      def initialize(params = {})
          
          @options = params.dup
          
            @options.use            ||= "neato"
            @options.graphtype      ||= "digraph"
            @options.nodelabels     ||= true
            @options.splines        ||= true
            @options.graphout       ||= :dot
            @options.colour_code    ||= true
            @options.showedges      ||= true
            @options.nodesize       ||= 2
            @options.fontsize       ||= 5
            @options.nodeshape      ||= "circle"
            @options.nodestyle      ||= "filled"
            @options.nodecolor      ||= false
          
          @input  = @options.input
          @root   = GraphViz.new(:G,:use=>@options.use,:type=>@options.graphtype,:splines=>@options.splines,:fillcolor=>"red",:rankdir=>"LR")
          
          # set global graph settings
          @root.node[:fontsize] = @options.fontsize
          @root.edge[:fontsize] = @options.fontsize
          
          @colour_map = Hash.new()
          
          generate
       end
      
      # run the script
      def generate
            build_graph
          create_legend
            output
      end
      
      def output
        @root.output(@options.graphout=>@options.output)
      end
      
      # build the dot file
      # @param none
      def build_graph
          
          RDF::Graph.load(@options.file).each do |statement|
              subject   = statement.subject
              predicate = statement.predicate
              object    = statement.object
              
              edge(predicate,node(subject),node(object))
          end
      end
     
      # create an edge between two nodes
      # @param [RDF::URI] the uri of the edge (predicate)
      # @param [GraphViz::Node] node1 the tail of the edge
      # @param [GraphViz::Node] node2 the head of the edge
      # @return[GraphViz::Edge] 
      def edge(resource,node1,node2)    
          label = fetch_fragment(resource) if(@options.showedges)
          color = colour_map(resource) if (@options.colour_code)
          @root.add_edge(node1,node2,:label=>label,:color=>color)
      end
      
      # color code RDF namespaces 
      # @param [RDF::URI] resource the URI to be color coded.
      # @return [String] hex color code corresponding to particular namespace
      def colour_map(uri)
          namespace = fetch_namespace(uri)
          if(!@colour_map.has_key?(namespace))
            color = "#"+"%06x" % (rand * 0xffffff)
            @colour_map.store(namespace,color)
          else
            color =  @colour_map.fetch(namespace)
          end
        return color
      end
      # create a graph node.
      # params [GraphViz::Graph] the graph the node is going to be added to
      # params [RDF::URI]  the uri the node will represent
      # return {GraphViz::Node] a graph node.
      def node(resource)
          color = colour_map(resource) if (@options.colour_code)
          label = fetch_fragment(resource) if(@options.nodelabels)
          @root.add_node(resource.to_s,:label=>label, :size=>@options.nodesize, :shape=>@options.nodeshape,:fillcolor=>color,:style=>@options.nodestyle)
      end

      # get the namespace of the URI passed in.
      # @params [String] uri the uri component of a triple part
      # @returns [String] the namespace frant of the string
      def fetch_namespace(resource)
          uri = Addressable::URI.parse(resource.to_s)
          
          if(uri.fragment != nil)
             return "#{uri.host}#{uri.path}"
          elsif(resource.to_s.include?("bio2rdf.org"))
            #template = Addressable::Template.new("http://{host}/{first}:{fragment}")
            #template = template.extract(uri)
            ns = resource.to_s.split(":")
            return ns[0..(ns.length-1)].join(":")
            #return "#{template["host"]}#{template["first"]}"
          end
      end
=begin      
      # find a cluster for a given namespace
      # set style of subgraph, filled with random colour.
      # store and return the subgraph
      def cluster(resource)
          ns = fetch_namespace(resource)
          
          cluster = ""
          
          if(!@clusters.has_key?(Digest::MD5.hexdigest(ns)))
            color = "%06x" % (rand * 0xffffff)
              cluster = @root.subgraph("cluster_#{Digest::MD5.hexdigest(ns)}",:label=>"#{ns}",:color=>"##{color}",:rank=>'min')
              #cluster.node["fillcolor"] = color
            @clusters.store(Digest::MD5.hexdigest(ns),cluster)
          else
            cluster = @clusters.fetch(Digest::MD5.hexdigest(ns))
          end
         
          return cluster
      end
=end
      # examine the URI for the fragment return "blank" otherwise
      def fetch_fragment(resource)
        uri = Addressable::URI.parse(resource.to_s)
        return uri.fragment
      end
      
      
    # Create the color coded legend for the graph
    # @params none
    # @return none
    def create_legend
        legend = @root.subgraph("cluster_legend",:label=>"legend",:splines=>false,:mindist=>0)
        
        legend.node[:shape=>"box"]
        legend.node[:fontsize=>10]
        legend.edge[:style=>"invis"]
        legend.edge[:len=>0]
        legend.graph[:rankdir=>"TB"]
        legend.graph[:sep=>0]
        legend.graph[:overlap=>"false"]
            
        l = @colour_map.flatten(1)
       
        i=0
        while(i<l.size)
           
            ns    = legend.add_node(l[i],:label=>l[i])
            value = legend.add_node(l[i+1],:label=>"",:fillcolor=>l[i+1])
            legend.add_edge(ns,value,:len=>0)
            
          if(i+3<l.size)  
            nextns    = legend.add_node(l[i+2], :label=>l[i+2])
            nextvalue = legend.add_node(l[i+3],:label=>"",:fillcolor=>l[i+3])
            legend.add_edge(nextvalue,ns)
            legend.add_edge(ns,nextns)
            legend.add_edge(value,nextvalue)
          end
            i+=2
        end 
    end
 end
end



#####################################################################################################################
# Start of the command line application
####################################################################################################################

class App
    
    def initialize(args)
        @arguments = args
        @options   = OpenStruct.new()
        @log       = Logger.new(STDOUT)
    end
    
    #run the application.
    def run
        
        @log.info "Running Program"
        
        if (process_arguments && arguments_valid?)
            RDFVisualGraph::Rdf2Dot.new(@options)
        else
            @log.error "Unable to run program:"
        end
    end
    
    def process_arguments()
        
        opts_parse = OptionParser.new do |opts|
            
            # set the input file.
            opts.on('-f','--file FILE',"the RDF file to be converted. only supports ntriples")    {|f| @options.file = File.expand_path(f)}
            opts.on('--shownodes BOOLEAN',"show nodes") {|value| @options.shownodes = value}
            opts.on('--use VALUE',"use the layout program, dot, svg etc")         {|use| @options.use = use }
            opts.on('--type VALUE',"not sure add what this does!")        {|type| @options.type = type}
            opts.on('--splines BOOLEAN',"use splines or not. better for larger graphs")   {|boolean| @options.splines = boolean}
            opts.on('--cluster BOOLEAN','build subgraphs based on namespace')   {|boolean| @options.cluster = boolean}
            opts.on('--showedges BOOLEAN',"show labels for edges") {|boolean| @options.showedges = boolean}
            opts.on('--nodesize VALUE',"set the default node size.")    {|value| @options.nodesize = value}
            opts.on('--nodeshape SHAPE',"set the default nodeshape.")   {|shape|@options.shape = shape}
            opts.on('--nodecolor COLOR',"set the default node color")   {|color| @options.color = color}
            opts.on('-o','--output FILE',"output the file here.")  {|f| @options.output = File.expand_path(f)}
            
            opts.on('-h','--help') do 
                puts opts
                exit!
            end
            
        end
        opts_parse.parse!(@arguments) rescue return false
        return true
    end
    
    def arguments_valid?
        begin
            
            if(@options.file)
                raise LoadError,"The file you specified doesn't exist: #{@options.file}" if File.exist?(@options.file) == false
                else
                @log.error "There was no input file. Use -f to specify input"
                exit!
            end
            
            if(@options.output)
                raise DirectoryError,"The directory you specified as the outpath doesn't exist: #{@options.output}" if(!File.basename(@options.output))
                else
                @log.error "There was no output file specified. Use -o to specify output file."
                exit!
            end
            
            
            rescue LoadError => bam
            @log.error bam
            exit!
            rescue DirectoryError => boom
            @log.error boom
            exit!
        end
        
        return true
    end
end

class DirectoryError < LoadError; end

# run the application.
App.new(ARGV).run
